/*
 * fhss.c
 *
 *  Created on: 19/10/2015
 *      Author: Caio Gustavo Mesquita Ângelo
 */

#include <stdio.h>
#include <stdint.h>
#include "fhss.h"

int rx_to_buf(RingBuffer* buf_rx, RingBuffer* buf_fh)
{
	uint8_t symb[M];
	uint8_t symbol;
	int i;

	while ( (buf_rx->ndata > 0) && (buf_fh->length - buf_fh->ndata >= M) ) // Verifica se tem algo no buf_rx e espaço para escrever em buf_fh
	{
		// Read next symbol
		if ( !RingBuffer_read(buf_rx, &symbol, 1) )
		{
			printf("\n\rFAILED READING BUF_RX");
			return 0;
		}

		for(i=0; i<M; i++) // Bits mais significativos devem vir primeiro sempre
			symb[i] = (symbol >> i) & 1;
		if ( !RingBuffer_write(buf_fh, symb, M) )
		{
			printf("\n\rFAILED WRITING BUF_FH");
			return 0;
		}
	}

	return 1;
}

int buf_to_tx(RingBuffer* buf_tx, RingBuffer* buf_fh)
{
	uint8_t symb[M];
	uint8_t symbol;
	int i;

	while ( (buf_tx->length - buf_tx->ndata > 0) && (buf_fh->ndata >= M) ) // Verifica se tem algo no buf_rx e espaço para escrever em buf_fh
	{
		// Read next bit
		// Bits mais significativos devem ir primeiro sempre
		symbol = 0;
		if ( !RingBuffer_read(buf_fh, symb, M) )
		{
			printf("\n\rFAILED READING BUF_FH");
			return 0;
		}

		for(i=0; i<M; i++)
			symbol = symbol | ( symb[i]<<i );//symb[i] = (symbol >> i) & 1;
		if ( !RingBuffer_write(buf_tx, &symbol, 1) )
		{
			printf("\n\rFAILED WRITING BUF_TX");
			return 0;
		}
	}

	return 1;
}

int extract_payload(RingBuffer *buf_rx, RingBuffer *buf_fh, uint8_t *payload)
{
	uint8_t last_bits[3] = {2, 2, 2}; //last_bits[0] é o mais atual e last_bits[2] é o mais antigo
	uint8_t temp;
	int step = 1;
	int size = 0;
	int hash;
	int i;
	int count = 0;

	while(step < 7)
	{
		if ( !rx_to_buf(buf_rx, buf_fh) ) // Atualiza buf_fh o que der: pressupõe-se que a velocidade de atualização é maior que a taxa de transmissão de dados... isso é importante para não se perderem dados
		{
			printf("\n\rFAILED UPDATING BUF_FH");
			return 0;
		}
		switch(step){
			case 1: // Etapa 1: Espera pelos bits de sincronização
				while(buf_fh->ndata > 0)
				{
					// Vai ler um bit novo, então deve-se guardar os 2 mais recentes
					last_bits[2] = last_bits[1];
					last_bits[1] = last_bits[0];
					// Lê um bit
					if ( !RingBuffer_read(buf_fh, last_bits, 1) )
					{
						printf("\n\rFAILED READING BUF_FH");
						return 0;
					}
					if( last_bits[0]==last_bits[2] && last_bits[0]!=last_bits[1]) // Encontrou uma sequência "010" ou "101"
					{
						step++;
						break;
					}
				}
				break;
			case 2: // Etapa 2: Procura início do fim do prêambulo (coincidência entre os últimos 2 bits). O fim é 11001100
				while(buf_fh->ndata > 0)
				{
					// Vai ler um bit novo, então deve-se guardar o último
					last_bits[1] = last_bits[0];
					// Lê um bit
					if ( !RingBuffer_read(buf_fh, last_bits, 1) )
					{
						printf("\n\rFAILED READING BUF_FH");
						return 0;
					}
					if( last_bits[0]==last_bits[1]) // Encontrou uma sequência "010" ou "101"
					{
						step++;
						break;
					}
				}
			case 3: // Etapa 3: Recebe o restante do preâmbulo e confere se está correto. 11001100 = 204 em decimal
				if( buf_fh->ndata > 5)
				{
					temp = (last_bits[1]<<7) | (last_bits[0]<<6);
					for(i=5; i>=0; i--)
					{
						if ( !RingBuffer_read(buf_fh, last_bits, 1) )
						{
							printf("\n\rFAILED READING BUF_FH");
							return 0;
						}
						temp = temp | (last_bits[0]<<i);
					}
					if( temp!=204 )
					{
						printf("\n\rFAILED GETTING PREAMBLE");
						return 0;
					}
					step++;
				}
				break;
			case 4: // Etapa 4: Lê o campo SIZE (tamanho do payload em bytes)
				if( buf_fh->ndata >= 8*SIZE_BYTES )
				{
					size = 0;
					for(i=8*SIZE_BYTES-1; i>=0; i--)
					{
						if ( !RingBuffer_read(buf_fh, last_bits, 1) )
						{
							printf("\n\rFAILED READING BUF_FH");
							return 0;
						}
						size = size | (last_bits[0]<<i);
					}
					step++;
				}
				break;
			case 5: // Etapa 5: Lê o payload
				while( buf_fh->ndata > 7 && count<size)
				{
					temp = 0;
					for( i=7; i>=0; i--)
					{
						if ( !RingBuffer_read(buf_fh, last_bits, 1) )
						{
							printf("\n\rFAILED READING BUF_FH");
							return 0;
						}
						temp = temp | (last_bits[0]<<i);
					}
					payload[count]=temp;
					count++;
				}
				if( count==size )
					step++;
				break;
			case 6: // Etapa 6: Lê o hash do payload, calcula o hash que deveria dar e compara para verificar a integridade do quadro
				if( buf_fh->ndata >= HASH_BYTES)
				{
					hash = 0;
					for(i=HASH_BYTES-1; i>=0; i--)
					{
						if ( !RingBuffer_read(buf_fh, last_bits, 1) )
						{
							printf("\n\rFAILED READING BUF_FH");
							return 0;
						}
						hash = hash | (last_bits[0]<<i);
					}
					if( hash != hash)//calc_hash(payload) ) // FALTA FAZER ESSA FUNÇÃO DO HASH
					{
						printf("\n\rFRAME CORRUPTED");
						return 0;
					}
					step++;
				}
			default:
				break;
		}
	}
	return size;
}

