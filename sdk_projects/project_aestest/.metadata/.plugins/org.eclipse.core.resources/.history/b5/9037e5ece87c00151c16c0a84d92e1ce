/*
 * fhss.c
 *
 *  Created on: 19/10/2015
 *      Author: Caio Gustavo Mesquita Ângelo
 */

#include <stdio.h>
#include <stdint.h>
#include "fhss.h"

int rx_to_buf(RingBuffer* buf_rx, RingBuffer* buf_fh)
{
	uint8_t symb[M];
	uint8_t symbol;
	int i;

	while ( (buf_rx->ndata > 0) && (buf_fh->length - buf_fh->ndata >= M) ) // Verifica se tem algo no buf_rx e espaço para escrever em buf_fh
	{
		// Read next symbol
		if ( !RingBuffer_read(buf_rx, &symbol, 1) )
		{
			printf("\n\rFAILED READING BUF_RX");
			return 0;
		}

		for(i=0; i<M; i++) // Bits mais significativos devem vir primeiro sempre
			symb[i] = (symbol >> i) & 1;
		if ( !RingBuffer_write(buf_fh, symb, M) )
		{
			printf("\n\rFAILED WRITING BUF_FH");
			return 0;
		}
	}

	return 1;
}

int buf_to_tx(RingBuffer* buf_tx, RingBuffer* buf_fh)
{
	uint8_t symb[M];
	uint8_t symbol;
	int i;

	while ( (buf_tx->length - buf_tx->ndata > 0) && (buf_fh->ndata >= M) ) // Verifica se tem algo no buf_rx e espaço para escrever em buf_fh
	{
		// Read next bit
		// Bits mais significativos devem ir primeiro sempre
		symbol = 0;
		if ( !RingBuffer_read(buf_fh, symb, M) )
		{
			printf("\n\rFAILED READING BUF_FH");
			return 0;
		}

		for(i=0; i<M; i++)
			symbol = symbol | ( symb[i]<<i );//symb[i] = (symbol >> i) & 1;
		if ( !RingBuffer_write(buf_tx, &symbol, 1) )
		{
			printf("\n\rFAILED WRITING BUF_TX");
			return 0;
		}
	}

	return 1;
}

int extract_payload(RingBuffer *buf_rx, RingBuffer *buf_fh, uint8_t *payload)
{
	uint8_t last_bit = 2;
	uint8_t cur_bit;
	int step = 1;
	int size = 0;

	while(step < 7)
	{
		rx_to_buf(buf_rx, buf_fh); // Atualiza buf_fh o que der: pressupõe-se que a velocidade de atualização é maior que a taxa de transmissão de dados... isso é importante para não se perderem dados
		switch(step){
			case 1: // Etapa 1: Espera pelos bits de sincronização
				while(buf_fh->ndata > 0)
				{
					// Lê um bit
					if ( !RingBuffer_read(buf_fh, &cur_bit, 1) )
					{
						printf("\n\rFAILED READING BUF_FH");
						return 0;
					}
					if( cur_bit == 1 && last_bit == 0) // Encontrou uma sequência "01"
					{
						step++;
					}
					last_bit = cur_bit;
				}
				break;
			case 2:
			default:
				break;
		}


	}


	return 1;
}

